use std::collections::BTreeMap;
use std::io::{self};
use std::path::Path;

use serde_yaml::to_string as to_yaml_string;

mod file_util;

/// Main struct for generating Loot rules.
pub struct Lootifier {
    plugins: Vec<String>,
}

impl Lootifier {
    /// Creates a new `Lootifier` instance from a file.
    pub fn from_file<P: AsRef<Path>>(path: P) -> io::Result<Self> {
        let plugins = file_util::read_lines_from_file(&path)?;
        Ok(Lootifier { plugins })
    }

    /// Creates a new `Lootifier` instance from a string.
    pub fn from_string(input: &str) -> io::Result<Self> {
        let plugins = file_util::filter_lines(input.lines())?;
        Ok(Lootifier { plugins })
    }

    /// Escapes characters within a string.
    fn escape_string(string: &str) -> String {
        string.replace('\'', "''")
    }

    /// Generates group rules based on the plugins.
    fn generate_group_rules(escaped_plugins: &[String]) -> Vec<LootRule> {
        escaped_plugins
            .windows(2)
            .map(|window| LootRule {
                name: window[1].clone(),
                after: Some(window[0].clone()),
                group: None,
            })
            .collect()
    }

    /// Generates plugin rules based on the plugins.
    fn generate_plugin_rules(escaped_plugins: &[String]) -> Vec<LootRule> {
        escaped_plugins
            .iter()
            .map(|plugin| LootRule {
                name: plugin.clone(),
                after: None,
                group: Some(plugin.clone()),
            })
            .collect()
    }

    /// Generates Loot rules in YAML format.
    pub fn generate_rules(&self) -> io::Result<String> {
        let escaped_plugins: Vec<_> = self
            .plugins
            .iter()
            .map(|plugin| Self::escape_string(plugin))
            .collect();

        let loot_groups_rules = Self::generate_group_rules(&escaped_plugins);
        let loot_plugin_rules = Self::generate_plugin_rules(&escaped_plugins);

        // not using a HashMap for rules_map to guarantee the order of plugins and groups
        let mut rules_map: BTreeMap<&str, &Vec<LootRule>> = BTreeMap::new();
        rules_map.insert("groups", &loot_groups_rules);
        rules_map.insert("plugins", &loot_plugin_rules);

        to_yaml_string(&rules_map)
            .map_err(|err| io::Error::other(err.to_string()))
    }
}

/// Struct for holding Loot rules.
#[derive(serde::Serialize)]
struct LootRule {
    name: String,
    #[serde(skip_serializing_if = "Option::is_none")]
    after: Option<String>,
    #[serde(skip_serializing_if = "Option::is_none")]
    group: Option<String>,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_rules() {
        let input_str = r#"
# This file was automatically generated by Mod Organizer.
Skyrim.esm
Update.esm
Dawnguard.esm
HearthFires.esm
Dragonborn.esm
Lanterns Of Skyrim II.esm
LegacyoftheDragonborn.esm
DynDOLOD.esm
Last' Plugin with '''.esm
"#;

        let expected_output_str = r#"
groups:
- name: Update.esm
  after: Skyrim.esm
- name: Dawnguard.esm
  after: Update.esm
- name: HearthFires.esm
  after: Dawnguard.esm
- name: Dragonborn.esm
  after: HearthFires.esm
- name: Lanterns Of Skyrim II.esm
  after: Dragonborn.esm
- name: LegacyoftheDragonborn.esm
  after: Lanterns Of Skyrim II.esm
- name: DynDOLOD.esm
  after: LegacyoftheDragonborn.esm
- name: Last'' Plugin with ''''''.esm
  after: DynDOLOD.esm
plugins:
- name: Skyrim.esm
  group: Skyrim.esm
- name: Update.esm
  group: Update.esm
- name: Dawnguard.esm
  group: Dawnguard.esm
- name: HearthFires.esm
  group: HearthFires.esm
- name: Dragonborn.esm
  group: Dragonborn.esm
- name: Lanterns Of Skyrim II.esm
  group: Lanterns Of Skyrim II.esm
- name: LegacyoftheDragonborn.esm
  group: LegacyoftheDragonborn.esm
- name: DynDOLOD.esm
  group: DynDOLOD.esm
- name: Last'' Plugin with ''''''.esm
  group: Last'' Plugin with ''''''.esm
"#
            .trim();

        let lootifier = Lootifier::from_string(input_str).unwrap();
        let result = lootifier.generate_rules().unwrap();

        assert_eq!(result, expected_output_str);
    }
}
